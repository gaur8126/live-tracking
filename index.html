<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Bus Tracking â€” ETA Visible</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" />
  <style>
    body { margin:0; padding:0; display:flex; height:100vh; font-family:Arial, sans-serif; }
    #map { flex:2; height:100vh; }
    #sidebar { flex:1; background:#fff; padding:12px; overflow:auto; box-shadow:-2px 0 6px rgba(0,0,0,0.08); }
    h3 { margin:6px 0 12px; }
    label { font-weight:600; font-size:13px; }
    select, button { width:100%; padding:8px; margin-top:6px; margin-bottom:8px; font-size:14px; }
    #info { background:#f6f6f6; padding:10px; border-radius:6px; margin-bottom:10px; }
    #etaBox { background:#fff; padding:8px; border-radius:6px; margin-bottom:10px; border:1px solid #eee; }
    #directions { border:1px solid #e0e0e0; padding:8px; border-radius:6px; max-height:52vh; overflow:auto; }
    /* hide LRM UI if it appears */
    .leaflet-routing-container, .leaflet-routing-instruction, .leaflet-routing-alt { display:none !important; }
  </style>
</head>
<body>

  <div id="map"></div>

  <div id="sidebar">
    <h3>Bus Route Directions</h3>
    <div id="info">Loading route â€” please wait...</div>

    <div id="etaBox">
      <div><strong>ETA to final stop:</strong> <span id="etaFull">--</span></div>
      <div><strong>ETA to your destination:</strong> <span id="etaSegment">--</span></div>
      <div><strong>Remaining distance (final):</strong> <span id="distFull">--</span></div>
      <div><strong>Remaining distance (segment):</strong> <span id="distSegment">--</span></div>
    </div>

    <label for="start">Start stop</label>
    <select id="start"></select>

    <label for="end">Destination stop</label>
    <select id="end"></select>

    <button id="showSegmentBtn">Start My Journey</button>
    <!-- <button id="clearSegmentBtn" style="margin-top:6px;">Clear Highlight</button> -->

    <h4 style="margin-top:12px;">Turn-by-turn (outside map)</h4>
    <div id="directions">Directions will appear here</div>
  </div>

  <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

  <script>
  // ---------- Setup ----------
  const map = L.map('map').setView([27.139813, 77.791669], 11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 }).addTo(map);

  // update these paths if your images are elsewhere
  const busIcon = L.icon({ iconUrl: 'img/Copilot_20250913_142727.png', iconSize: [40,40] });
  const stopIcon = L.icon({ iconUrl: 'img/th.jpg', iconSize: [25,41] });
  const personIcon = L.icon({ iconUrl: 'img/Copilot_20250913_161751.png', iconSize: [35,35] });

  // Stops
  const myLocation = [27.139707, 77.790173];
  const busStops = [
    { coords: [27.094173, 77.670877], name: "Fatehpur Sikri" },
    { coords: [27.138157, 77.781248], name: "Kiraoli" },
    { coords: myLocation, name: "My Location" },
    { coords: [27.153282, 77.867605], name: "Mirahkur" },
    { coords: [27.160837, 77.932764], name: "Patholi" },
    { coords: [27.176523, 78.008116], name: "AGRA" }
  ];

  // UI elements
  const startSelect = document.getElementById('start');
  const endSelect = document.getElementById('end');
  const infoBox = document.getElementById('info');
  const directionsBox = document.getElementById('directions');
  const etaFullEl = document.getElementById('etaFull');
  const etaSegmentEl = document.getElementById('etaSegment');
  const distFullEl = document.getElementById('distFull');
  const distSegmentEl = document.getElementById('distSegment');
  const showSegmentBtn = document.getElementById('showSegmentBtn');
  const clearSegmentBtn = document.getElementById('clearSegmentBtn');

  // build markers & dropdowns
  const stopMarkers = [];
  busStops.forEach((s, idx) => {
    const m = (s.name === "My Location")
      ? L.marker(s.coords, {icon: personIcon}).addTo(map).bindPopup(s.name + " ðŸ‘¤")
      : L.marker(s.coords, {icon: stopIcon}).addTo(map).bindPopup(s.name);
    stopMarkers.push(m);
    startSelect.innerHTML += `<option value="${idx}">${s.name}</option>`;
    endSelect.innerHTML   += `<option value="${idx}">${s.name}</option>`;
  });

  // ---------- Routing: compute full route once ----------
  const routingControl = L.Routing.control({
    waypoints: busStops.map(s => L.latLng(s.coords)),
    createMarker: () => null,
    addWaypoints: false,
    routeWhileDragging: false,
    fitSelectedRoutes: false,
    show: false
  }).addTo(map);

  let fullCoords = [];
  let fullLine = null;
  let stopIndices = [];
  let busMarker = null;
  let segmentLayer = null;
  let avgSpeed_mps = 0;
  let segmentIndices = null; // {startIdx, endIdx} into fullCoords

  routingControl.on('routesfound', function(ev){
    const route = ev.routes[0];
    if (!route) { infoBox.innerText = 'Routing failed.'; return; }

    // store coords
    fullCoords = route.coordinates.map(c => ({ lat:c.lat, lng:c.lng }));
    if (fullLine) map.removeLayer(fullLine);
    fullLine = L.polyline(fullCoords.map(c=>[c.lat,c.lng]), { color:'#d9534f', weight:4, opacity:0.85 }).addTo(map);

    // summary & directions
    const distKm = (route.summary.totalDistance/1000).toFixed(2);
    const etaMin  = Math.round(route.summary.totalTime/60);
    infoBox.innerHTML = `<b>Full route:</b> ${distKm} km, ${etaMin} min`;
    distFullEl.innerText = `${distKm} km`;
    etaFullEl.innerText  = `${etaMin} min`;
    directionsBox.innerHTML = '';
    if (route.instructions && route.instructions.length){
      route.instructions.forEach((ins,i)=>{
        const dKm = (ins.distance/1000).toFixed(2);
        directionsBox.innerHTML += `<div style="padding:6px 4px;border-bottom:1px solid #eee"><b>${i+1}.</b> ${ins.text} <div style="color:#666;font-size:12px">${dKm} km</div></div>`;
      });
    } else {
      directionsBox.innerText = 'No textual instructions available from router.';
    }

    // average speed from route summary (m/sec)
    avgSpeed_mps = route.summary.totalDistance / Math.max(route.summary.totalTime, 1);

    // compute nearest route index for each stop
    stopIndices = busStops.map(stop => {
      let bestIdx = 0, bestD = Infinity;
      for (let i=0;i<fullCoords.length;i++){
        const d = haversineMeters(fullCoords[i].lat, fullCoords[i].lng, stop.coords[0], stop.coords[1]);
        if (d < bestD){ bestD = d; bestIdx = i; }
      }
      return bestIdx;
    });

    // create bus marker
    if (!busMarker){
      busMarker = L.marker([fullCoords[0].lat, fullCoords[0].lng], { icon: busIcon }).addTo(map);
      busMarker.bindTooltip("ETA: --", { permanent:true, direction:'top', offset:[0,-20] });
    } else {
      busMarker.setLatLng([fullCoords[0].lat, fullCoords[0].lng]);
    }

    map.fitBounds(fullLine.getBounds(), { padding:[30,30] });

    // start animation
    startAnimation();
  });

  // ---------- Helpers ----------
  function haversineMeters(aLat,aLng,bLat,bLng){
    function toRad(x){ return x * Math.PI/180; }
    var R=6371000;
    var dLat=toRad(bLat-aLat), dLon=toRad(bLng-aLng);
    var s= Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*Math.sin(dLon/2)*Math.sin(dLon/2);
    var c=2*Math.atan2(Math.sqrt(s), Math.sqrt(1-s));
    return R*c;
  }
  function sumMetersBetween(idxA, idxB){
    if (!fullCoords || fullCoords.length===0) return 0;
    idxA = Math.max(0, Math.min(idxA, fullCoords.length-1));
    idxB = Math.max(0, Math.min(idxB, fullCoords.length-1));
    if (idxA > idxB) { const t=idxA; idxA=idxB; idxB=t; }
    let m = 0;
    for (let i=idxA; i<Math.min(idxB, fullCoords.length-1); i++){
      m += haversineMeters(fullCoords[i].lat, fullCoords[i].lng, fullCoords[i+1].lat, fullCoords[i+1].lng);
    }
    return m;
  }

  // ---------- Animation with pauses + ETA updates ----------
  const anim = { pos:0, playing:false, nextStopPtr:0, speedMs:70 };

  function startAnimation(){
    if (!fullCoords || fullCoords.length===0) return;
    anim.pos = 0;
    anim.nextStopPtr = 0;
    if (anim.playing) return;
    anim.playing = true;
    step();
  }

  function step(){
    if (!anim.playing) return;
    if (anim.pos >= fullCoords.length){
      anim.pos = 0;
      anim.nextStopPtr = 0;
      setTimeout(step, 1000);
      return;
    }

    const c = fullCoords[anim.pos];
    busMarker.setLatLng([c.lat, c.lng]);

    // ETA to final (dynamic): remaining meters / avgSpeed_mps
    let remainingMetersFull = sumMetersBetween(anim.pos, fullCoords.length - 1);
    let remSecsFull = avgSpeed_mps > 0 ? Math.round(remainingMetersFull / avgSpeed_mps) : 0;
    let remMinFull = Math.max(0, Math.round(remSecsFull / 60));
    etaFullEl.innerText = `${remMinFull} min`;
    distFullEl.innerText = `${(remainingMetersFull/1000).toFixed(2)} km`;
    busMarker.setTooltipContent(`ETA: ${remMinFull} min`);

    // ETA to highlighted segment end (if any)
    if (segmentIndices){
      const startIdx = segmentIndices.startIdx;
      const endIdx   = segmentIndices.endIdx;
      // determine where to start summation: either anim.pos (if already past segment start) or startIdx
      const segFrom = Math.max(anim.pos, startIdx);
      let remainingSegMeters = 0;
      if (segFrom <= endIdx){
        remainingSegMeters = sumMetersBetween(segFrom, endIdx);
      } else {
        remainingSegMeters = 0;
      }
      let remSegSecs = avgSpeed_mps > 0 ? Math.round(remainingSegMeters / avgSpeed_mps) : 0;
      let remSegMin = Math.max(0, Math.round(remSegSecs / 60));
      etaSegmentEl.innerText = `${remSegMin} min`;
      distSegmentEl.innerText = `${(remainingSegMeters/1000).toFixed(2)} km`;
    } else {
      etaSegmentEl.innerText = `--`;
      distSegmentEl.innerText = `--`;
    }

    // Pause at stops: if we are exactly at a stop index, pause
    if (anim.nextStopPtr < stopIndices.length && anim.pos === stopIndices[anim.nextStopPtr]){
      const stopName = busStops[anim.nextStopPtr].name;
      infoBox.innerHTML = `Bus reached stop: <b>${stopName}</b>`;
      try { stopMarkers[anim.nextStopPtr].openPopup(); } catch(e){}
      if (anim.nextStopPtr === stopIndices.length - 1){
        infoBox.innerHTML = `âœ… Bus reached FINAL stop: ${stopName}`;
        busMarker.setTooltipContent('ETA: 0 min');
        anim.nextStopPtr = 0;
        anim.pos++;
        setTimeout(step, 3000);
        return;
      } else {
        anim.nextStopPtr++;
        anim.pos++;
        setTimeout(step, 2500); // pause 2.5s at stops
        return;
      }
    }

    // otherwise keep moving
    anim.pos++;
    setTimeout(step, anim.speedMs);
  }

  // ---------- Segment highlight handling ----------
  showSegmentBtn.addEventListener('click', function(){
    const s = parseInt(startSelect.value,10);
    const e = parseInt(endSelect.value,10);
    if (isNaN(s) || isNaN(e) || s >= e){ alert('Choose valid Start < Destination'); return; }
    if (!fullCoords || fullCoords.length===0){ alert('Route not ready yet. Wait a moment.'); return; }

    // remove old layer
    if (segmentLayer) { map.removeLayer(segmentLayer); segmentLayer = null; segmentIndices = null; }

    const startIdx = stopIndices[s];
    const endIdx   = stopIndices[e];
    const slice = (startIdx <= endIdx) ? fullCoords.slice(startIdx, endIdx+1) : fullCoords.slice(endIdx, startIdx+1);
    const poly = slice.map(p => [p.lat, p.lng]);
    segmentLayer = L.polyline(poly, { color:'#1f78ff', weight:6, opacity:0.95 }).addTo(map);
    map.fitBounds(segmentLayer.getBounds(), { padding:[30,30] });

    // store indices for dynamic ETA compute
    segmentIndices = { startIdx: Math.min(startIdx,endIdx), endIdx: Math.max(startIdx,endIdx) };

    // compute static distance & ETA for whole segment (approx)
    const segMeters = sumMetersBetween(segmentIndices.startIdx, segmentIndices.endIdx);
    const segKm = (segMeters/1000).toFixed(2);
    const segSecs = avgSpeed_mps > 0 ? Math.round(segMeters / avgSpeed_mps) : 0;
    const segMin = Math.max(0, Math.round(segSecs / 60));
    infoBox.innerHTML = `Your journey: <b>${busStops[s].name}</b> â†’ <b>${busStops[e].name}</b><br>Distance: ${segKm} km<br>Approx ETA: ${segMin} min`;
  });

  clearSegmentBtn.addEventListener('click', function(){
    if (segmentLayer){ map.removeLayer(segmentLayer); segmentLayer = null; segmentIndices = null; }
    if (fullLine) map.fitBounds(fullLine.getBounds(), { padding:[30,30] });
    // restore full route summary if routingControl has it
    if (routingControl && routingControl.routes && routingControl.routes[0]) {
      try {
        const r = routingControl.routes[0];
        const dKm = (r.summary.totalDistance/1000).toFixed(2);
        const m = Math.round(r.summary.totalTime/60);
        infoBox.innerHTML = `<b>Full route:</b> ${dKm} km, ${m} min`;
        distFullEl.innerText = `${dKm} km`;
        etaFullEl.innerText  = `${m} min`;
      } catch (e) {
        infoBox.innerText = 'Full route loaded.';
      }
    }
  });

  // ---------------- Safety note in console if routing fails -------------
  // If you get an error that route cannot be calculated, it may be the OSRM public server (LRM default) is rate-limited or blocked by CORS.
  // For production / heavy testing use your own routing instance or a paid API.
  </script>
</body>
</html>
